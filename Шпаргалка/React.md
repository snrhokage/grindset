---
tags:
  - react
---

## ЖЦК

Существует четыре различных этапа жизненного цикла компонента React:

- **Инициализация**: На этом этапе компонент React готовит установку начального состояния и параметров по умолчанию.
- **Монтирование**: Компонент React готов для монтирования в DOM браузера. Этот этап охватывает методы жизненного цикла `componentWillMount и componentDidMount`.
- **Обновление**: На этом этапе компонент обновляется двумя способами, отправляя новые свойства и обновляя состояние. Этот этап охватывает методы жизненного цикла `shouldComponentUpdate, componentWillUpdate и componentDidUpdate`.
- **Размонтирование**: На этом последнем этапе компонент не нужен и отключается из DOM браузера. Этот этап включает метод жизненного цикла `componentWillUnmount`.
### ЖЦК в FC
#### useEffect
`useEffect` отчасти заменяет события жизненного цикла React. Он способен воспроизводить поведение методов **`componentDidMount, componentDidUpdate и componentWillUnmount`.**

## Хуки
- useState;
- useEffect;
- useLayoutEffect
- useContext;
- useRef;
- useMemo;
- useCallback;
- [[Новые хуки]]
### [[Новые хуки]]
### useCallback

Хук `useCallback` вернёт мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей. Это полезно при передаче колбэков оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для предотвращения ненужных рендеров
### useMemo

`useMemo` используется для того, чтобы закешировать\замемоизировать результат вычислений

Таким образом, **`useMemo`** используется для сохранения результатов тяжёлых вычислений, например обработка массива.

А **`useCallback`** используется, когда важна постоянность ссылок на функцию. Например, когда мы передаём ссылку в компонент, который использует `React.PureComponent` или `React.memo`, или, когда функция используется в качестве аргумента в других хуках

### useContext

В типичном React-приложении данные передаются сверху вниз (от родителя к дочернему компоненту) с помощью пропсов. Однако, подобный способ использования может быть чересчур громоздким для некоторых типов пропсов (например, выбранный язык, UI-тема), которые необходимо передавать во многие компоненты в приложении. Контекст предоставляет способ делиться такими данными между компонентами без необходимости явно передавать пропсы через каждый уровень дерева.
### **useRef**

`useRef` возвращает изменяемый ref-объект, свойство `.current` которого инициализируется переданным аргументом (initialValue). Возвращённый объект будет сохраняться в течение всего времени жизни компонента и не будет изменяться от рендера к рендеру.

### **React.memo**

`React.memo` — это компонент высшего порядка.

Если ваш компонент всегда рендерит одно и то же при неменяющихся пропсах, вы можете обернуть его в вызов React.memo для повышения производительности в некоторых случаях, мемоизируя тем самым результат. Это значит, что React будет использовать результат последнего рендера, избегая повторного рендеринга. React.memo затрагивает только изменения пропсов. Если функциональный компонент обёрнут в `React.memo` и использует `useState, useReducer или useContext`, он будет повторно рендериться при изменении состояния или контекста.
## **Fiber**

`Fiber` - это конкретная реализация [[#VirtualDom|Virtual DOM]], используемая в React.

`Fiber` обеспечивает высокую производительность рендеринга и упрощает поддержку сложных компонентов.

>`React Fiber` — прогрессивная реализация ключевого алгоритма React. Это кульминационное достижение двухгодичных исследований команды разработчиков React.

>Цель `Fiber` в увеличении производительности при разработке таких задач как анимация, организация элементов на странице и движение элементов. Ее главная особенность — это **инкрементный рендеринг**: способность разделять работу рендера на единицы и распределять их между множественными фреймами.

## Reconciliation?
[[Reconciliation]]
это алгоритм React, используемый для того, чтобы отличить одно дерево элементов от другого для определения частей, которые нужно будет заменить.

## `useImperativeHandle`

В React данные передаются от родительских к дочерним компонентам через свойства, известные как однонаправленный поток данных. Родительский компонент не может напрямую вызвать функцию, определенную в дочернем компоненте, или получить значение.

В определенных обстоятельствах мы хотим, чтобы наш родительский компонент обращался к дочернему компоненту, получая данные, которые происходят в дочернем компоненте, для собственного использования. Мы можем добиться такого типа потока данных с помощью хука **`useImperativeHandle`**, который позволяет нам предоставлять значение, состояние или функцию внутри дочернего компонента родительскому компоненту через ref. Вы также можете решить, к каким свойствам может получить доступ родительский компонент, тем самым сохраняя приватную область действия дочернего компонента.

`useImperativeHandle(ref, createHandle, [dependencies])`

## KEYS и как его сделать для массива?

если массив не будет меняться, можно использовать `index`. Если массив будет меняться, можно сгенерировать `uid` для каждого элемента с помощью какой либо библиотеки.

## `Error Boundary` Как перехватить ошибка внутри реакт компонента?

через `Error Boundary` которая оборачивает главный компонент приложения. Библиотека `react-error-boundary`, с опциями куда записать лог и что показать при размонтировании всего дерева при ошибке. Не ловит ошибки - при SSR, при сет таймаут, запросах и в самом обработчике.

## **setState()**

Состояние хранит в себе какие-то данные, и чтобы изменить эти данные необходимо вызвать функцию `setState()`.

Метод `setState()` следит за изменением состояния (state) компонента. `state` — это объект. Когда состояние меняется, компонент рендерится повторно и мы видим в браузере компонент с обновленными данными.

## VirtualDom

`VirtualDOM` это копия DOM дерева и вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его легковесной копией. Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого React применяет изменения к реальному DOM.

При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено. Такой подход работает быстрее, потому как не включает в себя все тяжеловесные части реального DOM.
## Props

`Props` – данные, которые передаются в компонент из родительского. `Props` доступны только для чтения и не могут быть изменены.

## JSX

По умолчанию чтобы создавать элементы в React используется такой синтаксис

```jsx
const elem = React.createElement(
	'h1',
	{ className: 'greeting'},
	'Чиназес'
);
```

Но мы привыкли видеть его вот таким. Именно такая разметка и называется jsx. Это некое расширение языка упрощающее восприятие кода и разработку

```jsx
const elem = (
	<h1 classsName="greeting">
		Чиназес
	</h1>
);
```