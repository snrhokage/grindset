S - Принцип единственной ответственности (The Single Responsibility Principle) каждый класс должен выполнять лишь одну задачу и все сервисы класса должны быть направлены на обеспечение этой обязанности. Например компонент должен отрисовать JSX и нежелательно чтобы axios/fetch запросы делались прямо в компонентах, это нужно выносить в отдельные переиспользуемые классы, функции, хуки. 

• O - Принцип открытости/закрытости (The Open Closed Principle) программные сущности должны быть открыты для расширения, но закрыты для модификации. В общем, этот принцип имеет в виду следующее: у нас должна быть возможность добавлять новый функционал, не трогая существующий код класса. 

• L - Принцип подстановки Барбары Лисков (The Liskov Substitution Principle) объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы. Наследующий класс должен дополнять, а не изменять базовый. Для того чтобы следовать принципу необходимо в базовый (родительский) класс выносить только общую логику, характерную для классов наследников, которые будут ее реализовывать и, соответственно, можно будет базовый класс без проблем заменить на его класс-наследник. 

• I - Принцип разделения интерфейса (The Interface Segregation Principle) много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения. Классы не должны реализовывать и зависить от методов, которые они не используют. Классы необходимо разделять на более специфические. В react – компоненты не должны зависеть от пропсов, которые они не юзают. 

• D - Принцип инверсии зависимостей (The Dependency Inversion Principle) классы должны зависеть от интерфейсов или абстрактных классов, а не от конкретных классов и функций. Высокоуровневые модули не должны зависеть от низкоуровневых модулей. Оба типа модулей должны зависеть от абстракций.


Без dependecny inversion
``` js
const sayHello = () =>{
	console.log('hey')
}

class Dog {
  constructor() {}

  helloWorld() {
    sayHello()
  }
}

const dog = new Dog();
dog.helloWorld();

```
В этом примере `Dog` зависит от конкретной реализации `sayHello`. Это нарушает принцип Dependency Inversion, так как высокоуровневый модуль (`Dog`) зависит от низкоуровневого модуля (`sayHello`).


C dependecny inversion
``` js
const sayHello = () =>{
	console.log('hey')
}

class Dog {
  constructor() {}

  helloWorld(func) {
    func()
  }
}

const dog = new Dog();
dog.helloWorld(sayHello);

```
Передаем функцию в качестве аргумента, Это позволяет `Dog` зависеть от абстракции `sayHello`, а не от конкретной реализации