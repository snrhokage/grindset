**Оптимизация** приложения, можно вкратце назвать весь список:

- Сжатие Gzip - уменьшит объем данных, передаваемых сервером хостинга, браузеру клиента (обычно включено по умолчанию)

- Использование CDN для хранения изображений и других ресурсов

- Кеширование статики, шрифтов, изображений и так далее

- Разбитие кода на чанки, code-splitting webpack

- Использование HTTP 2 вместо HTTP 1

- Lazy loading - чтобы код подгружался не весь сразу при первой загрузке приложения, а только в тот момент, когда это будет нужно пользователю

- Борьба с лишними ререндерами с помощью useMemo, useCallback, memo

- Использовать Web-worker для выноса блокирующего кода, или тяжелых операций в отдельный поток

- Использовать виртуализацию или пагинацию для больших списков и таблиц

**Поподробнее**:

- Можем использовать lazy loading и разбиение на чанки, например с помощью React.lazy импортов и Suspense, чтобы у нас код подгружался не весь сразу при первой загрузке приложения, а небольшими частями в тот момент, когда это будет нужно.  
 - Можем использовать webpack минимайзеры css и js файлов (UglifyJsPlugin, Terser, MiniCssExtract), плагин для tree-shaking в webpack, кеширование статических файлов. Tree shaking – это удаление кода и импортов, которые фактически не используются.

- Можем использовать react.memo, usecallback, usememo для уменьшения количества ререндеров, - например в больших списках

- Использование виртуализации больших списков, чтобы рендерилось, например не 1000 элементов, а только те которые юзер видит на экране

- Оптимизация изображений - использование CDN, например s3 для хранения изображений, помогает уменьшить время подгрузки, так как данные будут подгружаться с ближайшего к юзеру сервера. Использовать Lazy loading images, Progressive Images

- Использование debounce/throttle, например в фильтрах, инпутах для поиска, чтобы запросы отправлялись не на каждый ввод в инпут, а с какой-то задержкой



**Throttle** – запускает вызовы функции с определённой периодичностью (как setInterval)

**Debounce** - откладывает вызов функции до того момента, когда с последнего вызова пройдёт заданное количество времени, которое мы передали в функцию (как setTimeout)



**Способы измерения производительности и метрик** –

- Вкладка performance в devtools,

- Lighthouse в девтулз для измерения метрик производительности,

- Использование Web-vitals,

- расширение React-profiler для отслеживания лишних ререндеров

- замер метрик с помощью сайта WebpageTest