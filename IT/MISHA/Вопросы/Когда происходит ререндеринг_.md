---
tags:
  - react
links:
  - https://habr.com/ru/companies/timeweb/articles/684718/
aliases:
---
[[Reconciliation]]
### Модификация состояния
### Ререндеринг предка
### Модификация контекста

### Модификация хука
Все, что происходит внутри хука, «принадлежит» использующему его компоненту. Здесь действуют те же правила:
- изменение состояния хука влечет безусловный ререндеринг «хостового» (host) компонента;
- если хук потребляет контекст, модификация контекста повлечет безусловный ререндеринг компонента, использующего хук.
### Изменение пропов (распространенное заблуждение)
До тех пор, пока речь не идет о мемоизированных компонентах, изменения пропов особого значения не имеют.

Модификация пропов означает их обновление родительским компонентом. Это, в свою очередь, означает ререндеринг родительского компонента, влекущий повторный рендеринг всех его потомков.

Изменения пропов становятся важными только при применении различных техник мемоизации ([[memo]], [[useMemo()]]).

## Предотвращение ререндеринга с помощью композиции

### Антипаттерн: создание компонентов в функции рендеринга
### Паттерн: перемещение состояния вниз
### Паттерн: передача потомков в виде пропов
### Паттерн: передача компонентов в виде пропов
### Предотвращение ререндеринга с помощью [[memo]]
### Повышение производительности ререндеринга с помощью хуков [[useCallback()]] и [[useMemo()]]
#### Антипаттерн: ненужная мемоизация пропов с помощью `useCallback/useMemo`
#### Обязательное применение `useMemo/useCallback`
Если дочерний компонент обернут в `React.memo`, все пропы, не являющиеся примитивами, должны быть предварительно мемоизированы.
### Использование `useMemo` для «дорогих» вычислений
Мемоизация пропов сама по себе не предотвращает ререндеринг дочернего компонента. Повторный рендеринг родительского компонента влечет безусловный ререндеринг его потомков независимо от пропов.

### Повышение производительности ререндеринга списков
#### Антипаттерн: произвольные значения пропа `key`

Значением `key` никогда не должны быть рандомные значения. Это приведет к перемонтированию элементов списка при каждом рендеринге, что повлечет за собой:
- очень низкую производительность списка;
- баги, связанные с неправильным состоянием компонентов или неуправляемых элементов (таких как поля для ввода).
### Предотвращение ререндеринга, вызываемого контекстом
#### Мемоизация значения, передаваемого провайдеру
Если провайдер контекста находится не на верхнем уровне приложения и существует вероятность того, что он подвергнется ререндерингу вследствие повторного рендеринга его предков, значение, передаваемое провайдеру, должно быть мемоизировано.

### Разделение данных и интерфейсов
### Разделение данных на части
### Селекторы контекста