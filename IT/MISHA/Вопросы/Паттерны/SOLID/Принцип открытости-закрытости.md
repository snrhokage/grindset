---
tags:
  - solid
links:
  - https://solidbook.vercel.app/ocp
---
[Принцип открытости-закрытости](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D0%B8/%D0%B7%D0%B0%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D0%B8) (Open-Closed Principle, OCP) помогает исключить такую проблему. Согласно ему модули должны быть открыты для расширения, но закрыты для изменения.

==Простыми словами — модули надо проектировать так, чтобы их требовалось менять как можно реже, а расширять функциональность можно было с помощью создания новых сущностей и композиции их со старыми.==

Основная цель принципа — помочь разработать проект, устойчивый к изменениям, срок жизни которых превышает срок существования первой версии проекта.

Модули, которые удовлетворяют OCP:

- _открыты для расширения_ — их функциональность может быть дополнена с помощью других модулей, если изменятся требования;
- _закрыты для изменения_ — расширение функциональности модуля не должно приводить к изменениям в модулях, которые его используют.

Нарушение принципа открытости-закрытости приводит к ситуациям, когда изменение в одном модуле вынуждает менять другие, связанные с ним. 

Это в свою очередь нарушает [[Принцип единственной ответственности]], потому что весь код, который меняется по какой-то одной причине, должен быть собран в одном модуле. (Разные модули — разные причины для изменения.)

## На примере

На схеме ниже объект `Client` непосредственно связан с объектом `Server`. Если нам вдруг понадобится, чтобы `Client` мог работать с разными объектами `Server`, нам придётся поменять его код.

Чтобы решить эту проблему, необходимо связывать объекты не напрямую, а через абстракции. Если все объекты `Server` реализуют интерфейс `Abstract Server`, то нам уже не придётся менять код объекта `Client` для замены одного объекта `Server`на другой.

### Вместо этого

OCP же предлагает не проверять конкретные типы, а использовать абстракцию, которая позволит не менять код класса `Notifier`. Для этого мы создадим интерфейс `Sender`, который будут реализовывать классы `SmsSender`, `PushSender` и `EmailSender`:

```ts
// Интерфейс будет абстракцией, которая описывает контракт,
// по которому должны работать классы, реализующий этот интерфейс:

interface Sender {
  sendMessage(message: MessageText): void
}

class SmsSender implements Sender {
  sendMessage(message: MessageText) {
    /* То, что раньше было внутри метода `sendSms`. */
  }
}

class PushSender implements Sender {
  sendMessage(message: MessageText) {
    /* То, что раньше было внутри метода `sendPush`. */
  }
}

class EmailSender implements Sender {
  sendMessage(message: MessageText) {
    /* То, что раньше было внутри метода `sendEmail`. */
  }
}
```

Тогда классу `Notifier` перестанет быть нужно проверять конкретный тип, и он сможет положиться на контракт, описанный в интерфейсе:

```ts
class Notifier {
  constructor(private api: Sender) {}

  notify(): void {
    const message = 'Some user notification';
    this.api.sendMessage(message);
  }
}
```

### В результате

Теперь при _добавлении_ голубиной почты, нам уже не потребуется _менять_ код класса `Notifier`, зависящего от интерфейса `Sender`:

```ts
class DoveSender implements Sender {
  sendMessage(message: MessageText) {
    /* То, что раньше было внутри метода `sendDove`. */
  }
}

// Код класса `Notifier` останется тем же.
```

Таким образом, вводя адекватную абстракцию мы «расцепляем» модули. Мы делим зоны ответственности между разными частями приложения и уменьшаем количество кода, который нужно изменять при добавлении новой функциональности.

## Коротко

Принцип открытости-закрытости:

- заставляет проектировать модули так, чтобы они делали только одну вещь и делали её хорошо;
- побуждает связывать сущности через абстракции (а не реализацию) там, где могут поменяться бизнес-требования;
- обращает внимание проектировщиков на места стыка и взаимодействие сущностей;
- позволяет сократить количество кода, который необходимо менять при изменении бизнес-требований;
- делает внесение изменений безопасным и относительно дешёвым.

# Шаблоны проектирования и приёмы рефакторинга

## [[Абстрактная фабрика]]

## [[Стратегия]]

## [[Декоратор]]

## [[Наблюдатель]]
## Замена прямого наследования на полиморфизм и композицию

Модули, зависящие от конкретных классов, связаны с ними слишком сильно, из-за чего изменение в одном модуле затронет изменение в другом.

[Замена](https://blog.aspiresys.pl/technology/example-of-just-in-time-design-refactor-to-open-closed/) прямого наследования на полиморфизм или композицию — это приём рефакторинга, который ослабляет зацепление модулей через введение абстракций: интерфейсов, обёрток и т. д.

Примером может послужить [пример](https://solidbook.vercel.app/ocp/in-ideal-world) из раздела «В идеальном мире», где мы вводили прослойку из интерфейса `Shape`. Когда класс `AreaCalculator` начинает зависеть от интерфейса, а не от конкретных классов, изменение в требованиях не затрагивает код класса `AreaCalculator`.

# Антипаттерны и запахи

## Связывание через конкретные классы

Проблемы связывания через конкретные классы мы рассмотрели в [примере](https://solidbook.vercel.app/ocp/in-ideal-world)из раздела «В идеальном мире». Класс `AreaCalculator` изначально зависел от конкретного класса `Rectangle`, из-за чего при изменении требований, приходилось обновлять код этого класса.

Когда мы ввели прослойку в виде интерфейса `Shape`, класс `AreaCalculator` начинал зависеть от интерфейса, а не от конкретных классов, изменение в требованиях перестало затрагивать код класса `AreaCalculator`.

## [[Синглтон]]

[Синглтон](https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)) — это паттерн, при котором в приложении существует только один экземпляр какого-то класса. Существующий синглтон гарантирует, что все новые созданные объекты будут ссылаться на него.

Если синглтон содержит в себе общее состояние или глобальные переменные, либо сам является глобальной сущностью, то зацепление объектов с ним [чрезмерно высокое](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D1%86%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)).

Это может приводить к ситуациям, когда при изменении требований приходится менять и сам синглтон, и все объекты, которые с ним связаны.

Синглтон можно использовать и без высокого зацепления модулей (применяя, например, абстрактные интерфейсы), но это значительно усложняет структуру проекта.

## [[Легковес]]

[Легковес](https://refactoring.guru/ru/design-patterns/flyweight) — шаблон, который уменьшает расход памяти, держа общее состояние объектов внутри себя, вместо хранения одинаковых данных в каждом объекте.

Его проблема с точки зрения OCP в том же высоком связывании модулей. Если сущность выступает в роли общего контекста для нескольких объектов, при изменении требований придётся менять код каждого модуля.

Как и в случае с синглтоном, с легковесом можно работать без высокого зацепления, но это также будет увеличивать сложность.

# Ограничения и подводные камни
## Система не может быть закрыта на 100%

Всегда есть изменения, которые невозможно внести, не изменив код какого-то модуля, поэтому при проектировании важен стратегический подход. Необходимо определить, от каких именно изменений и какие именно модули вы хотите закрыть.

Следует учитывать, что люди очень плохо умеют прогнозировать изменения. Даже имея достаточно знаний о системе и опыта, проектировщики не могут быть уверены, что предусмотрели все возможные варианты развития системы.

OCP предлагает подход [Just-in-time design](https://agiledesign.org/2015/01/18/jit-just-in-time-and-software-development/), при котором новые сущности добавляются в систему по мере необходимости, но не раньше. Это чем-то похоже на отказ от ранней оптимизации и [раннего добавления абстракций](http://tonsky.me/blog/concrete-vs-abstract/).

Цель подхода в том, чтобы не создавать абстракции на пустом месте. Один из критериев хорошего дизайна — простота, поэтому использовать OCP следует всегда с оглядкой на то, насколько система получится простой в итоге.

## Большое количество сущностей

Добавление функциональности менее рискованно, чем изменение существующей, но взамен мы рискуем [увеличить количество сущностей](https://softwareengineering.stackexchange.com/questions/170547/refactoring-and-open-closed-principle). Бесконтрольное и бездумное следование OCP может приводить к ситуациям, когда интерфейсов станет слишком много, а функциональность — станет раздробленной.

Хороший дизайн системы — это в первую очередь простой дизайн. Чем меньше сущностей мы создаём для решения проблемы, тем [выше вероятность, что дизайн хороший](https://ru.wikipedia.org/wiki/%D0%94%D0%B7%D0%B5%D0%BD_%D0%9F%D0%B8%D1%82%D0%BE%D0%BD%D0%B0), поэтому следовать OCP необходимо с осторожностью.

## Может быть не нужен для маленьких приложений

OCP нацелен на быстрое и дешёвое добавление функциональности и масштабирование системы. Он окупается, если система действительно большая, и проверять, как повлияло изменение кода, очень дорого или долго (или невозможно).

Если же приложение маленькое, то OCP может [превратиться в принцип ради принципа](https://www.tonymarston.net/php-mysql/not-so-solid-oo-principles.html) — когда разработчики будут писать бойлерплейт-код для создания новых сущностей без видимой и ощутимой пользы.

OCP следует применять, если польза от него значительно выше, чем затраты от следования ему.