---
links:
  - https://t.me/frontend_dev_path/49
  - https://t.me/lavka_og/6
tags: 
aliases:
---
## Над вами:
- Тех. дир - 1
- Проджект менеджер - 1
- Старший аналитик - 1
- Лид тестировщиков - 1
## У вас в команде:
- Продукт менеджер (ПМ) - 1
- Тимлид - 1
- Бекендеры - 3
- Фронтендеры - 2
- Тестировщики - 2
- Аналитик - 2
- Дизайнер - 1

## Подготовка:

**Проджект** с вашим **продуктом** и **аналитиками** все обговорили, требования собрали, в идеале даже какую-то документацию написали, наметили план работы, добавили задач в беклог.

### Задачи не берутся из воздуха. 

Их создают `разработчики` и `бизнес-аналитики` — люди, которые формулируют то, что хочет бизнес, в понятный для команды язык. 

>Если бизнес хочет стул, то бизнес-аналитик расписывает дизайнерам, как этот стул должен выглядеть, а бекендерам и фронтендерам — как его реализовать.

### Эти задачи попадают в беклог.
`Беклог` — это большое ведро, где лежат задачи. 
Там лежат как новые, необработанные задачи, назовем их "Новая", так и задачи из остальных категорий. 

Затем вы все собираетесь и начинаете обсуждение по срокам. ПМ рассказывает по приоритету и вы накидывайте задач в двухнедельный спринт (работаете вы по SCRUM).

Аналитики продолжают писать документацию и требования согласно ТЗ, параллельно консультируясь с бекендерами и дизайнером, а он в свою очередь с фронтами.

После чего ПМ, если задачи не были к тому моменту созданы/заведены в систему управления проектами ([[#Jira|Jira]]) это делает. Затем тимлид распределяет задачи между разработчиками (на свое усмотрение или по желанию разработчика). 
## Процесс:

Разработчик берет задачу которая на него заасайнили (прикреплена) в работу. Создает под нее ветку в `GIT` с номером задачи. Делает, то что указано в ТЗ, если есть комментарии или проблемы, консультируется с **аналитиком или тимлидом**. 

Если задача связана с фронтом, то идет взаимодействие с фронтендерами. Идет согласование методов, подготовка API документации.

После того, как задача готова, отправляет ее на ревью (проверку) другому разработчику.

Далее задача заливается на `дев\тестовый\стейдж` сервер, где уже ее проверяют тестировщики.

### Как выглядит задача
Давайте её откроем. Что мы там увидим? 

Чаще всего, две ссылки: `ссылка на документацию и ссылка на дизайн`. 

**Документация**, если мы используем Jira, скорее всего будет написана в продукте от той же компании — `Confluence`. 

>Если очень просто, то это обычный портал, где описано, как должны работать фичи, как должен работать бек и фронт. 
  

## Завершение:

Есть несколько вариантов в зависимости от процесса релиза. Обычно коммиты копятся в отдельной ветке и перед релизом заливаются в мастер, а он на отдельный STAGE сервер.

После чего происходит запуск пайплайнов, которые делают билд, запускают тесты, подготавливают к деплою.

Если все прошло без ошибок, то происходит деплой на прод. И тестировщики делают регресс тестирование.
  

✅ Это в около идеальном мире. В реальности все работает со своими дополнениями или упрощениями. Хуже если уходит в бюрократию и процессы ради процессов. Новичку в такое лезть не стоит.
## Jira

Вы берете задачу в работу, работаете и затем заканчиваете над ней работать, попутно перетягивая её карточку из этих категорий.
### Статусы
Статусы могут варьироваться от проекта к проекту, но, грубо говоря, выглядит все так:
- "Можно брать в работу"
- "В работе"
- "В ревью"
- "Ревью пройдено"
- "Готово к тестированию"
- "В тестировании"
- "Сделано"
## Груминг
Время от времени несколько человек на проекте собираются на такой мит, называется он `груминг`, и решают, что можно брать в работу, перемещая это в соответствующую категорию. 

## Эпик
Задачи, независимо от их статуса, могут разделяться на специальные категории, называемые `Эпик`. Это группа задач по одной теме. 

### У задачи есть оценка по времени. 

Её может ставить `тимлид`, её можете ставить вы сами. Она может быть как в часах, так и в [[#Что же такое сторипоинт?|сторипоинтах]]. 

Если проект адекватный, то оценка в 4 часа означает, что в идеальном мире задача, по мнению оценивающего, заняла бы 4 часа, но
а) могут быть проблемы, 
б) оценивающий может ошибаться. 

Оценка на нормальных проектах происходит не для того, чтобы наказать разработчика, если он в неё не уложится, а чтобы понимать, правильно ли вообще оцениваются задачи, основываясь на том, во сколько задача была оценена и сколько времени разработчик на неё затратил. 

## Что же такое сторипоинт? 

Допустим, есть две задачи: сделать стул, сделать трон. Сделать стул занимает X времени, сделать трон — 10X, то есть в десять раз **сложнее**. А сделать стул со встроенным унитазом еще сложнее — 20X. Теперь давайте заменим X на SP — сторипоинт. Сделать стул занимает 1SP, сделать трон — 10SP, сделать трон с унитазом — 20SP. То есть сторипоинт просто показывает, насколько задача сложнее или проще других задач на проекте. Если одна задача занимает 1SP, а вторая 2SP, то, значит, вторая в два раза сложнее. А задача в 10SP сложнее вышесказанных в 10 и 5 раз соответственно.

## Первым делом 
я кликаю на дизайн и смотрю, как там что нарисовано. 
Я изучаю разные состояния страницы просмотра заказа: 
- когда заказ выполнен (и есть форма запроса возврата денег), 
- когда заказ в процессе (и можно видеть, где он сейчас), 
- когда у него ошибка (и можно написать в поддержку). 

## Затем
если мне все понятно, я приступаю к следующему шагу. Если нет, я захожу в документацию — `confluence` — и пробегаюсь глазами по тому, что должно быть реализовано.

### Если мне все еще не понятно
я пишу `бизнес-аналитикам` или `тимлиду` и выясняю детали.
  
## Дальше 
я смотрю, реализован ли `бекенд` для моей задачи,
ибо иногда бывает такое, что для задачи с бекенда могут приходить не все данные. 

Например, вам нужно отобразить статус заказа (в процессе, ошибка, выполнен), а его нет в данных, что вам приходят. 
В таком случае я пишу бекам, чтобы они это сделали, **и переключаюсь на другую задачу, проделывая шаги выше.**
  
Допустим, все хорошо, все данные есть и все детали мне известны. 

## Приступаем к фиче. 

- Я захожу в редактор кода и открываю терминал. 

- В нем я переключаюсь на ветку `develop`. Это ветка, где лежит код, который еще не видят пользователи, но который уже написан разработчиками. 

- Я пишу `git pull`, чтобы влить себе последние изменения и работать с актуальным кодом. Это очень важно сделать, поскольку может быть очень больно, когда вы сделаете фичу и обнаружите, что писали её поверх старого кода, который больше не существует. 

- Затем я пишу `git checkout -b feat/номер_задачи-order-view-page`. Эта команда создаст новую ветку и сразу переместится на неё. Примерно так оформляется название ветки. Может быть по-другому, естественно.

- Я её сделал. 

- Я пишу `git commit` (либо, скорее, открываю коммит в редакторе кода), и указываю в сообщении коммита, что же такое я сделал. Например, я пишу `"feat: order view page"`, где `feat` означает, что я сделал фичу (может быть `fix` — фикс, `perf` — улучшение производительности, `ref` — рефактор, и т.д. `semantic commits`), и `order view page` — страница просмотра заказа, то есть краткое описание того, что я сделал.


## Дальше нам нужно отправить это на ревью
и вот как мы сделаем. 

Когда вы используете гит, вы делаете все локально. Но, если вы делали пет-проекты, вы, скорее всего, заливали их на гитхаб. 

>`Гитхаб` — это не единственное место, куда можно заливать код. Есть еще такие штуки как `BitBucket`, `GitLab`, которые часто используют на коммерческих проектах.

Мы не пушили код в `main` или `dev`, ведь сначала его должны посмотреть наши коллеги.

Дальше мы открываем такую вещь, которая называется `pull request` или `merge request`. 

>Если объяснить человеческим языком, то мы как бы "открываем запрос на merge, то есть **вливание нашей фичи** в dev".

Мы открываем `merge request` в `develop`, да, нам надо нашу фичу туда. Заходим в `Jira`, и перетягиваем нашу задачу из "В работе" в "В ревью".

Затем его смотрит один или несколько наших коллег оставляет комментарии по нашему коду. 

Мы их читаем, возможно спорим, делаем правки по комментариям, и получаем "апрув". Это специальный индикатор на `гитлабе/гитхабе/битбаккете`, означающий, что наши коллеги одобрили наш `merge request` — и мы можем вливать его в `develop` (помните, мы открыли запрос именно в `dev`). 

Мы его туда вливаем и перетягиваем нашу задачу в "ревью пройдено". Иногда мы можем не вливать, а подождать, пока наши коллеги получат апрувы своих фичей, и вылить сразу несколько. 

Это полезно, чтобы убедиться, что фичи "не мешают" друг другу, и в случае чего созвониться и вместе порешать все мёрж конфликты (когда гит не знает, чей код воткнуть в файл).

Дальше процесс может варьироваться. Допустим, в течение нескольких дней мы с вами вливаем фичи в дев. Они там накапливаются, задачи висят в "ревью пройдено". Затем, когда они накопились, мы открываем MR из **dev** в ветку **для тестировщиков**, куда заходят и тыкают тестировщики, и в ветку **для разработчиков**, куда могут зайти и потыкать разработчики. Мы все проверяем и мержим (вливаем) его. 

Когда мы влили из develop в, скажем, dev-server и test-server (назовем их так), то запускается процесс деплоя — грубо говоря, выливания нашего кода "в свет" (для команды, не для пользователя). Запускается такой процесс, который мы назовем "пайп". Представьте себе трубу с несколькими этапами обработки. Наши фичи проходят эти этапы и, либо все проходит успешно, либо пайп падает. Если он падает, мы находим причину, в чем дело и чиним.

  

Дальше задача переходит в "Готово к тестированию". Там тестировщик забирает её себе и идет тестировать. И вот, он обнаруживает баг. Он создает новую задачу и, скорее всего, сразу же назначает её на разработчика, который делал фичу, в которой этот баг был найден. Если он срочный, мы с вами фиксим его сейчас и повторяем процесс выше, только выливаем сразу, если нет, то идем по всем стадиям.

  

Итак, теперь вам должно быть понятно в общих чертах, как устроен процесс разработки. Я опустил некоторые моменты, например процесс решения мёрж конфликтов, починку пайпа и работу в фигме — со всем этим можно разобраться на месте.