---
tags:
  - javascript
---
Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.

Символы создаются вызовом функции `Symbol()`, в которую можно передать описание (имя) символа.

Даже если символы имеют одно и то же имя, это – разные символы. Если мы хотим, чтобы одноимённые символы были равны, то следует использовать глобальный реестр: вызов `Symbol.for(key)` возвращает (или создаёт) глобальный символ с `key` в качестве имени. Многократные вызовы команды `Symbol.for` с одним и тем же аргументом возвращают один и тот же символ.

## Символы имеют два основных варианта использования:

1. «Скрытые» свойства объектов. Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке, мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в `for..in`, так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением, так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.
   
   Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.
   
2. Существует множество системных символов, используемых внутри JavaScript, доступных как `Symbol.*`. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем использовать `Symbol.iterator` для [итераторов](https://learn.javascript.ru/iterable), `Symbol.toPrimitive` для настройки [преобразования объектов в примитивы](https://learn.javascript.ru/object-toprimitive) и так далее.


Технически символы скрыты не на 100%. Существует встроенный метод [Object.getOwnPropertySymbols(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols) – с его помощью можно получить все свойства объекта с ключами-символами. Также существует метод [Reflect.ownKeys(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys), который возвращает _все_ ключи объекта, включая символьные. Так что они не совсем спрятаны. Но большинство библиотек, встроенных методов и синтаксических конструкций не используют эти методы.

`JSON.stringify()` игнорирует свойства с ключами `Symbol`:

```jsx
JSON.stringify({[Symbol("foo")]: "foo"});
// '{}'
```

## Технические символы (Well-known symbols )

### `Symbol.iterator` 
— известный символ, задающий итератор объекта, используемый по умолчанию. Применяется в конструкции `for...of`.

Каждый раз, когда объект должен быть проитерирован (как, например, в начале цикла `for..of`), метод `@@iterator` вызывается без аргументов, а возвращённый итератор используется непосредственно для получения значений.

Некоторые встроенные типы имеют стандартное итерационное поведение, в то время как другие типы таким свойством не обладают. Метод `@@iterator` имеют следующие встроенные типы:
- `[Array.prototype[@@iterator]()]`
- `[TypedArray.prototype[@@iterator]()`
- `[String.prototype[@@iterator]()]`
- `[Map.prototype[@@iterator]()`
- `[Set.prototype[@@iterator]()`

Если метод @@iterator объекта не возвращает итератор, то это плохо оформленный итерируемый объект, его использование, скорее всего, приведёт к возникновению исключений или неправильному поведению

### `Symbol.asyncIterator`

### `Symbol.match`
— известный символ, определяющий соответствие строки регулярному выражению. Этот метод вызывается функцией `String.prototype.match()`.

Данный метод также используется для того, чтобы определить, обладает ли объект поведением регулярного выражения. Например, методы `String.prototype.startsWith()`, `String.prototype.endsWith()` и `String.prototype.includes()` проверяют, является ли первый аргумент регулярным выражением, и бросают TypeError, если это так. Соответственно, если символ match установлен в false (или имеет ложное значение) — это говорит о том, что объект не предназначен для использования в качестве регулярного выражения.

Ошибка:

```jsx
"/bar/".startsWith(/bar/); // Бросает TypeError, так как /bar/ является
                           // регулярным выражением и Symbol.match не изменён.
```

Сработает:

```jsx
var re = /foo/;
re[Symbol.match] = false;
"/foo/".startsWith(re); // true
"/baz/".endsWith(re);   // false
```

### `Symbol.matchAll`
### `Symbol.replace`

**`Symbol.replace`** — известный символ, задающий метод для замены подстрок в строке. Эта функция вызывается методом `[String.prototype.replace()]

### `[Symbol.search]`

Метод, возвращающий индекс вхождения подстроки, соответствующей регулярному выражению. Используется функцией `[String.prototype.search()]

### `[Symbol.split]`

Метод, разбивающий строку на части в местах, соответствующих регулярному выражению. Используется функцией `[String.prototype.split()]

### `[Symbol.hasInstance]`

Метод, определяющий, распознает ли конструктор некоторый объект как свой экземпляр. Используется оператором `[instanceof]

### `[Symbol.isConcatSpreadable]`
Булево значение, показывающее, должен ли объект быть сведён к плоскому представлению (англ. flatten) в виде массива его элементов функцией `[Array.prototype.concat()]

### `[Symbol.unscopables]`
Массив строковых имён свойств. Позволяет скрыть свойства от инструкции `with` (прежде всего для обратной совместимости).

### `[Symbol.species]`

Метод, определяющий конструктор для порождённых объектов.

### `[Symbol.toPrimitive]`

Метод, преобразующий объект в примитив (примитивное значение).

### `[Symbol.toStringTag]`

Строковое значение, используемое в качестве описания объекта по умолчанию. Используется функцией `[Object.prototype.toString()](<https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/toString>)`