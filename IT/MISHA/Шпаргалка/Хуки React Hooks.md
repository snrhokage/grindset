---
tags:
  - react
  - hooks
---
Хуки — **это функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненного цикла React из функциональных компонентов**. Хуки не работают внутри классов — они дают вам возможность использовать React без классов.
## Новые
### [[useId()]]

это хук React для генерации уникальных идентификаторов, которые могут быть переданы атрибутам доступности. Полезен например [Атрибуты доступности HTML](https://developer.mozilla.org/docs/Web/Accessibility/ARIA), такие как `[aria-describedby] `, позволяют указать, что два тега связаны друг с другом. Например, вы можете указать, что элемент (например, input) описывается другим элементом (например, абзацем).
### startTransition и [[useTransition()]]

`startTransition` и `useTransition` позволяют помечать некоторые обновления состояния как несрочные. Другие обновления состояния по умолчанию считаются срочными. React позволит срочным обновлениям состояния (например, обновлению ввода текста) прерывать несрочные обновления состояния (например, отображение списка результатов поиска).
### [[useInsertionEffect()]]

`uselnsertionEffect` - это новый хук, который позволяет библиотекам CSS-in-JS решать проблемы с производительностью при внедрении стилей во время рендеринга. 

Если вы не планируете создавать библиотеку CSS-in-JS, мы не ожидаем, что вы когда-либо будете это использовать. Этот хук запустится после изменения DOM, но до того как эффекты лейаута узнают об этом. 

Это решает проблему, которая уже существует в React 17 и более ранних версиях, но еще более важна в React 18, поскольку React уступает браузеру во время одновременного рендеринга, давая ему возможность пересчитать лейаут.
### [[useSyncExternalStore()]]
это хук React, позволяющий подписаться на внешнее хранилище. `const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)`
### [[useDeferredValue()]]
вернет отложенную версию значения используется для уменьшения частоты дорогостоящего повторного рендеринг, изменения которое вернет хук будет помечено как не приоритетное и будет применено к дереву DOM когда браузер будет свободным
### [[useDebugValue()]]
`useDebugValue` может использоваться для отображения метки для пользовательских хуков в` React DevTools.`

### [[useImperativeHandle()]]
`useImperativeHandle` настраивает значение экземпляра, которое предоставляется родительским компонентам при использовании `ref`. Как всегда, в большинстве случаев следует избегать императивного кода, использующего ссылки. `useImperativeHandle` должен использоваться с `forwardRef`

## Экспериментальные
### [[useFormStatus()]]
### [[useFormState()]]
### [[use()]]
### [[useOptimistic()]]

## Старые

### [[useCallback()]]
Передайте встроенный колбэк и массив зависимостей. Хук `useCallback` вернёт мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей. Это полезно при передаче колбэков оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для предотвращения ненужных рендеров
### [[useContext()]]
Принимает объект контекста (значение, возвращённое из `React.createContext`) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом `value` ближайшего `<MyContext.Provider>` над вызывающим компонентом в дереве.
### [[useState()]]
Возвращает значение с состоянием и функцию для его обновления.
### [[useEffect()]]
Принимает функцию, которая содержит императивный код, возможно, с эффектами. Будет вызвана асинхронно не блокируя поток Хотя `useEffect` откладывается до тех пор, пока браузер не выполнит отрисовку, он гарантированно срабатывает перед любыми новыми рендерами. React всегда полностью применяет эффекты предыдущего рендера перед началом нового обновления

### [[useRef()]]
useRef возвращает изменяемый ref-объект, свойство .current которого инициализируется переданным аргументом (initialValue). Возвращённый объект будет сохраняться в течение всего времени жизни компонента.

### [[useReducer()]]
Альтернатива для [[useState()]]. Принимает редюсер типа `(state, action) => newState` и возвращает текущее состояние в паре с методом `dispatch`
### [[useLayoutEffect()]]

Сигнатура идентична `useEffect`, но этот хук запускается синхронно после всех изменений DOM. Используйте его для чтения макета из DOM и синхронного повторного рендеринга. Обновления, запланированные внутри `useLayoutEffect`, будут полностью применены синхронно перед тем, как браузер получит шанс осуществить отрисовку.

### [[useMemo()]]
Передайте «создающую» функцию и массив зависимостей. `useMemo` будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.