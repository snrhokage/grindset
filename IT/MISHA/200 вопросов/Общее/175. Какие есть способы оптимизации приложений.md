**Оптимизация** приложения, можно вкратце назвать весь список:

- Сжатие Gzip - уменьшит объем данных, передаваемых сервером хостинга, браузеру клиента (обычно включено по умолчанию)
- Использование CDN для хранения изображений и других ресурсов
- Кеширование статики, шрифтов, изображений и так далее
- Разбитие кода на чанки, code-splitting webpack
- Использование HTTP 2 вместо HTTP 1
- Lazy loading - чтобы код подгружался не весь сразу при первой загрузке приложения, а только в тот момент, когда это будет нужно пользователю
- Борьба с лишними ререндерами с помощью useMemo, useCallback, memo
- Использовать Web-worker для выноса блокирующего кода, или тяжелых операций в отдельный поток
- Использовать виртуализацию или пагинацию для больших списков и таблиц

**Поподробнее**:

- Можем использовать lazy loading и разбиение на чанки, например с помощью React.lazy импортов и Suspense, чтобы у нас код подгружался не весь сразу при первой загрузке приложения, а небольшими частями в тот момент, когда это будет нужно.  
 - Можем использовать webpack минимайзеры css и js файлов (UglifyJsPlugin, Terser, MiniCssExtract), плагин для tree-shaking в webpack, кеширование статических файлов. Tree shaking – это удаление кода и импортов, которые фактически не используются.
- Можем использовать react.memo, usecallback, usememo для уменьшения количества ререндеров, - например в больших списках
- Использование виртуализации больших списков, чтобы рендерилось, например не 1000 элементов, а только те которые юзер видит на экране
- Оптимизация изображений - использование CDN, например s3 для хранения изображений, помогает уменьшить время подгрузки, так как данные будут подгружаться с ближайшего к юзеру сервера. Использовать Lazy loading images, Progressive Images
- Использование debounce/throttle, например в фильтрах, инпутах для поиска, чтобы запросы отправлялись не на каждый ввод в инпут, а с какой-то задержкой

**Throttle** – запускает вызовы функции с определённой периодичностью (как setInterval)

**Debounce** - откладывает вызов функции до того момента, когда с последнего вызова пройдёт заданное количество времени, которое мы передали в функцию (как setTimeout)

**Способы измерения производительности и метрик**:
- Вкладка performance в devtools,
- Lighthouse в девтулз для измерения метрик производительности,
- Использование Web-vitals,
- расширение React-profiler для отслеживания лишних ререндеров
- замер метрик с помощью сайта WebpageTest