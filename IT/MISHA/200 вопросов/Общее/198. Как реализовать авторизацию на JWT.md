Примерный алгоритм:

1.    Пользователь вводит логин и пароль, отправляется запрос на сервер, который возвращает ответ с 2 токенами, access и refresh

2.    Можно сохранять токены в localStorage или cookie, но localStorage уязвим к XSS атакам, так как к нему есть доступ из js, поэтому лучше хранить токены в cookie с флагами httpOnly (чтобы не было доступа к куки из js, для защиты от XSS атак) и secure (чтобы куки передавались только по защищенному https протоколу)

3.    Этот токен мы можем отправлять в заголовке Authorization: `Bearer ${наш токен}`, вместе с запросом на бэк, для доступа к которым нужна авторизация, это можно сделать с помощью axios-interceptors для request. 

Пример кода, чтобы с каждым запросом отправлялся хедер с токеном:
![[Pasted image 20240519162750.png]]


4.    На бэке будут получать этот токен, валидировать его и проверять есть ли доступ у данного юзера к запрошенным данным

5.    Чтобы обработать кейс, когда срок жизни токена истек, во время запроса, мы также можем повесить axios-interceptor на response, который будет проверять, если ответ имеет статус 401 (Unauthorized), то мы пытаемся получить новую пару токенов, используя текущий refresh-токен, который хранится у нас в куках

6.    Если запрос на получение новой пары токенов успешен, мы сохраняем их в куки, обновляем токен в заголовке Authorization и повторяем оригинальный запрос, который упал с 401 ошибкой

Пример кода:
![[Pasted image 20240519162813.png]]

**access token** - используется для авторизации запросов и хранения дополнительной информации о пользователе (user_id, user_role или еще что либо). Более короткоживущий токен.

**refresh token** - выдается сервером по результам успешной аутентификации (логин/рег) и используется для получения новой пары **access/refresh** токенов. Имеет большой срок жизни.