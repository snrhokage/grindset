Virtual DOM - это легковесная копия DOM, хранимая в оперативной памяти, которая синхронизируется с RDOM. Помогает избежать прямой работы с DOM из-за проблем с производительностью, т.к у нас при каждом изменении DOM в чистом js происходят тяжеловесные операции в браузере по типу layout, painting, reflow (а из-за того, что VDOM дерево хранится в виде простого отдельного js объекта (каждый элемент этого дерева тоже хранится в виде обьектов), мы можем свободно изменять его свойства, не затрагивая актуальный RDOM, до тех пор, пока нам это не понадобится. И потом точечно пакетно обновлять DOM дерево. То есть изменения VDOM сразу не отрисовываются на экране).

- При изменении состояния компонента, React обновляет VDOM. После обновления VDOM, React сравнивает его текущую версию дерева с предыдущей. (diffing) 
-  Затем вычисляется разница между предыдущим и новым представлениями DOM для определения того, какие части должны быть обновлены. (алгоритм reconcliation выполняет обход в глубину, начиная с корня дерева и сравнивает каждый элемент и его потомков) 
- После этого используя наработки из предыдущей фазы, вызываются методы жизненного цикла, хуки и обновляются только те части реального DOM, которые подверглись изменениям. React использует механизм пакетного обновления вместо обновления DOM при каждом изменении состояния.

React реализует эвристический алгоритм O(n), который основывается на двух предположениях: 
1. Два элемента с разными типами произведут разные деревья. При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. Если изменились атрибуты элемента, то обновятся только они, без уничтожения дерева. Когда компонент обновляется, его экземпляр остаётся прежним, поэтому его состояние сохраняется между рендерами.

2. Можно указать, какие дочерние элементы могут оставаться стабильными между разными рендерами с помощью пропа key. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева при рекурсивном обходе ДОМ-деревьев (ex: изменение порядка без ререндера). • Рендеринг родительского компонента приводит по умолчанию к рендерингу всех вложенных в него компонентов!