event loop – Это бесконечный цикл, в котором выполняются обработчики событий. Браузер распределяет эти обработчики по очередям (микротаски и макротаски). Асинхронный код выполняется в фоне и не блокирует основной поток. Макротаска это например – setTimeout, евенты, таймеры, fetch; Микрозадачи – промисы, queMicrotask(), mutationObserver. Все микрозадачи в очереди будут выполнены только после того, как текущий стек вызовов окажется пустым (и выполнится синхронный код), но перед выполнением следующей макрозадачи. Если МАКРО пораждает МИКРО, то выполнится МАКРО а после нее все МИКРО. Микро блочат луп, а макро нет. JS является однопоточным и eventloop позволяет браузеру обрабатывать асинхронные операции, не блокируя основной поток выполнения. 

Порядок выполнения кода: 
- Сначала выполняются все синхронные задачи 
- Потом выполняются все задачи из микротасков 
- После выполнения всех микротасков - очередь очищается 
- Затем мы берем одну макрозадачу из списка и выполняем ее 
- После выполнения мы смотрим нужно ли нам сделать перерисовку страницы 
- Если перерисовать страницу нужно - делаем это 

Call stack (LIFO) – стэк вызова функций, вызывается 1 функция, если внутри нее есть вызов еще одной функции, то она добавляется в стэк, после выполнения функции она убирается из стэка. Асинхронный код попадает в webAPI, когда webAPI его обрабатывает он попадает не в call stack, а в очередь (callback queue, FIFO). Из очереди они попадут в стек после того, как call stack будет полностью очищен и выполнится весь основной код. События (onClick, onChange) тоже попадают в webAPI и не засоряют call stack; После итерации event loop мы смотрим нужно ли нам сделать перерисовку страницы, выполняется Render.