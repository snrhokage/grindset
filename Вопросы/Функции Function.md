---
tags:
  - "#javascript"
---
## Стрелочные функции vs обычных?

- значением [[this Context контекст|this]] - у обычной функции `this` динамический (если объявлена как функция то глобальный объект `window`, если как метод объекта то сам объект, если через `call` или `apply` то первый аргумент, если через конструктор то саму сущность.
    **У стрелочной** `this = this внешней функции`**, своего нет.**
- обычную функцию можно **использовать как конструктор**, стрелку нет.
- `аргументы` - у обычной функции `аргументы = массив arguments`, у стрелочной - из внешней функции, или если нужно свои аргументы использовать то добавить деструктуризацию во внешнюю функцию - (...args).
- синтаксис
- область видимости
- нельзя вызвать с помощью оператора `new`
- не работает привязка контекста. [[Как работают bind, call и apply]]

## `function expression` vs `function declaration`

- `Function Declaration` обрабатываются перед выполнением блока кода. Они видны во всём блоке.
- Функции, объявленные при помощи `Function Expression`, создаются, только когда поток выполнения достигает их.

## Что такое контекст функции?
[[this Context контекст]]

## Какие бывают виды функций

### Анонимные функции:

```jsx
let anonymousFunction = function() {
	console.log('This is an anonymous function');
};
anonymousFunction();
```
### Функции обратного вызова:
```jsx
function callbackFunction(name, callback) {
	console.log('Hello, ' + name);
	callback();
}

function goodbye() {
	console.log('Goodbye!');
}

callbackFunction('Alice', goodbye);
```

### Стрелочные функции:
```jsx
let arrowFunction = () => {
	console.log('This is an arrow function');
};
arrowFunction();
```
### Функциональные выражения:
```jsx
let add = function(a, b) {
	return a + b;
};
console.log(add(3, 5));
```

### Функции как методы объектов:
```jsx
let person = {
	name: 'John',
	greet: function() {
		console.log('Hello, my name is ' + this.name);
	}
};

person.greet();
```

### Функции-конструкторы:
```jsx
function Car(make, model) {
	this.make = make;
	this.model = model;
	this.display = function() {
		console.log('This car is a ' + this.make + ' ' + this.model);
	};
}

let myCar = new Car('Toyota', 'Camry');
myCar.display();
```

### IIFE (Immediately Invoked Function Expression):
функция, которая выполняется сразу же после того, как она была определена.
```jsx
(function() {
	console.log('This is an IIFE');
})();
```

## Cтадии создания контекста выполнения функции

1. Определяется значение `this` и осуществляется привязка this (`this binding`).

2. Создается компонент `Lexical Environment` (лексическое окружение). Лексическое окружение состоит из записи окружения (`Environment Record`) и ссылки на внешнее лексическое окружение, которая может принимать значение `null`.

   1. В лексическом окружении имеется два компонента:
	    `Запись окружения`. Это место, где хранятся объявления переменных и функций.
        
        `Ссылка на внешнее окружение`. Наличие такой ссылки говорит о том, что у лексического окружения есть доступ к родительскому лексическому окружению (области видимости).

3. Создается компонент `Variable Environment` (окружение переменных).

    Окружение переменных (`Variable Environment`) — это тоже лексическое окружение, запись окружения которого хранит привязки, созданные посредством команд объявления переменных (`Variable Statement`) в текущем контексте выполнения.
    
    В ES6 существует одно различие между компонентами `LexicalEnvironment` и `VariableEnvironment`. Оно заключается в том, что первое используется для хранения объявлений функций и переменных, объявленных с помощью ключевых слов `let` и `const`, а второе — только для хранения привязок переменных, объявленных с использованием ключевого слова `var`.