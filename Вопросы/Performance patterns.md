---
tags:
  - patterns
links:
  - https://www.patterns.dev/vanilla/bundle-splitting
  - https://web.dev/articles/apply-instant-loading-with-prpl?hl=ru
  - https://youtu.be/VNNLNC5h7ZI?si=-a1vHb9P3-jv6a7L
---
## Bundle Splitting
При создании современного веб-приложения такие пакеты, как [Webpack](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/webpack.js.org/) или [Rollup](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/rollupjs.org/guide/en/), берут исходный код приложения и объединяют его в один или несколько пакетов. Когда пользователь посещает веб-сайт, пакет запрашивается и загружается для отображения данных на экране пользователя.

Движки JavaScript, такие как [V8](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/v8.dev/docs), способны анализировать и компилировать данные, запрошенные пользователем при их загрузке. Хотя современные браузеры эволюционировали, чтобы разбирать и компилировать код как можно быстрее и производительнее, разработчик по-прежнему отвечает за оптимизацию двух этапов процесса: времени загрузки и выполнения запрашиваемых данных. Мы хотим убедиться, что время выполнения максимально сокращено, чтобы предотвратить блокировку основного потока.
## Compressing JavaScript
### Сжатие HTTP
Сжатие данных HTTP может быть классифицировано по-разному. Один из них - с потерями или без потерь.

**Сжатие с потерями** подразумевает, что цикл сжатия-распаковки приводит к незначительному изменению документа при сохранении его удобства использования. Изменение в основном незаметно для конечного пользователя. Наиболее распространенным примером сжатия с потерями является сжатие изображений в формате JPEG.

При **сжатии без потерь,** данные, восстановленные после сжатия и последующей распаковки, будут точно соответствовать оригиналу. Изображения PNG являются примером сжатия без потерь. Сжатие без потерь имеет отношение к передаче текста и должно применяться к текстовым форматам, таким как HTML, CSS и JavaScript.
### Минимизация
Доступно множество инструментов для [минимизации ресурсов HTML, CSS и JS](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/developers.google.com/speed/docs/insights/MinifyResources). [Terser](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/github.com/terser-js/terser) - популярный инструмент сжатия JavaScript для ES6+, а [Webpack](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/webpack.js.org/) версии 4 по умолчанию включает плагин для этой библиотеки для создания уменьшенных файлов сборки. Вы также можете использовать `TerserWebpackPlugin` со старыми версиями Webpack или использовать Terser как инструмент командной строки без связывателя модулей.
### Статическое или динамическое сжатие
Минимизация помогает значительно уменьшить размеры файлов, но сжатие JS может обеспечить более значительный выигрыш. Сжатие на стороне сервера можно реализовать двумя способами.

**Статическое сжатие:** Вы можете использовать статическое сжатие для предварительного сжатия ресурсов и их заблаговременного сохранения как части процесса сборки. В данном случае вы можете позволить себе использовать более высокие уровни сжатия, чтобы сократить время загрузки кода. Большое время сборки не повлияет на производительность веб-сайта. Было бы лучше, если бы вы использовали статическое сжатие для файлов, которые меняются не очень часто.

**Динамическое сжатие:** При использовании этого процесса сжатие выполняется "на лету", когда браузер запрашивает ресурсы. Динамическое сжатие реализовать проще, но вы ограничены использованием более низких уровней сжатия. Более высокие уровни сжатия потребуют больше времени, и вы потеряете преимущество, полученное от меньших размеров контента. Было бы полезно, если бы вы использовали динамическое сжатие для контента, который часто меняется или создается приложением.
### Алгоритмы сжатия
[Gzip](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/datatracker.ietf.org/doc/html/rfc1952) и [Brotli](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/opensource.googleblog.com/2015/09/introducing-brotli-new-compression.html) - два [наиболее распространенных алгоритма](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/almanac.httparchive.org/en/2020/compression#fig-5), используемых сегодня для сжатия HTTP-данных.
### Включение сжатия
Вы можете включить статическое сжатие как часть сборки. Если вы используете Webpack для объединения своего кода, вы можете использовать [CompressionPlugin](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/github.com/webpack-contrib/compression-webpack-plugin) для сжатия Gzip или [BrotliWebpackPlugin](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/github.com/mynameiswhm/brotli-webpack-plugin) для сжатия Brotli. Плагин может быть включен в конфигурационный файл Webpack следующим образом.

Next.js обеспечивает [сжатие Gzip по умолчанию](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/nextjs.org/docs/api-reference/next.config.js/compression), но рекомендует включить его на HTTP-прокси, таком как Nginx. Как Gzip, так и Brotli поддерживаются на [платформе Vercel](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/vercel.com/docs/concepts/edge-network/compression) на уровне прокси.

Вы можете включить динамическое сжатие без потерь на серверах (включая Node.js), поддерживающих различные алгоритмы сжатия. Браузер сообщает о поддерживаемых им алгоритмах сжатия через HTTP-заголовок [Accept-Encoding](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/developer.mozilla.org/docs/Web/HTTP/Headers/Accept-Encoding) в запросе. Например, `Accept-Encoding: gzip, br`.

Brotli рекомендуется использовать по сравнению с другими алгоритмами сжатия, поскольку он генерирует файлы меньшего размера. Вы можете включить Gzip в качестве запасного варианта для браузеров, которые не поддерживают Brotli. В случае успешной настройки сервер вернет заголовок HTTP-ответа с [кодировкой содержимого](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/developer.mozilla.org/docs/Web/HTTP/Headers/Content-Encoding), чтобы указать алгоритм сжатия, используемый в ответе. Например, `Content-Encoding: br`.
## Dynamic Import
*В нашем приложении для общения в чате у нас есть четыре ключевых компонента: `UserInfo`, `ChatList`, `ChatInput` и `EmojiPicker`. Однако только три из этих компонентов используются мгновенно при начальной загрузке страницы: `UserInfo`, `ChatList` и `ChatInput`. `EmojiPicker` Не отображается напрямую и может вообще не отображаться, если пользователь даже не нажмет на `Emoji`, чтобы переключить `EmojiPicker`. Это означало бы, что мы без необходимости добавили `EmojiPicker` модуль в наш первоначальный пакет, что потенциально увеличило время загрузки!*
### React.Suspense
Простой способ динамического импорта компонентов в React - использовать `React.Suspense`. `React.Suspense`Компонент получает компонент, который должен быть динамически загружен, что позволяет `App` компоненту быстрее отображать свое содержимое, приостанавливая импорт `EmojiPicker` модуля! Когда пользователь нажимает на эмодзи, `EmojiPicker` компонент отображается в первый раз. `EmojiPicker` Компонент визуализирует `Suspense` компонент, который получает лениво импортированный модуль: `EmojiPicker` в данном случае. `Suspense` Компонент принимает `fallback` prop, который получает компонент, который должен быть отрисован, пока приостановленный компонент все еще загружается!
###  loadable-components
Рендеринг на стороне сервера не поддерживает React Suspense (пока). Хорошей альтернативой React Suspense является [`loadable-components`](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/loadable-components.com/docs/getting-started/) библиотека, которую можно использовать в приложениях SSR.
## Import On Interaction

Собственный JavaScript часто влияет на готовность современных страниц к взаимодействию в Интернете, но часто он может задерживаться в сети из-за некритичных JS из собственных или сторонних источников, которые загружают основной поток.

Как правило, избегайте синхронных сторонних скриптов в заголовке документа и старайтесь загружать неблокирующие сторонние скрипты после завершения загрузки JS первого производителя. Такие шаблоны, как импорт при взаимодействии, дают нам возможность отложить загрузку некритичных ресурсов до того момента, когда пользователю с гораздо большей вероятностью понадобится пользовательский интерфейс, которым он пользуется.
### “Поддельная” загрузка стороннего пользовательского интерфейса с фасадом
Когда пользователь нажимает на “предварительный просмотр” (фасад), загружается код ресурса. Это ограничивает пользователей необходимостью оплачивать стоимость использования функции, если они не собираются ее использовать. Аналогично, фасады могут [предварительно подключаться](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/web.dev/uses-rel-preconnect/) к необходимым ресурсам при наведении курсора мыши.
>Сторонние ресурсы часто добавляются на страницы без полного учета того, как они вписываются в общую загрузку сайта. Синхронно загружаемые сторонние скрипты блокируют анализатор браузера и могут задерживать загрузку. Если возможно, 3P-скрипт должен быть загружен с использованием async / defer (или других подходов), чтобы гарантировать, что 1P-скрипты не будут испытывать нехватки пропускной способности сети. Если они не критичны, они могут быть хорошим кандидатом для перехода к отложенной поздней загрузке с использованием шаблонов, таких как импорт при взаимодействии.

#### Встраивается видеоплеер
Хорошим примером “фасада” является [встраивание YouTube Lite](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/github.com/paulirish/lite-youtube-embed) от Пола Айриша. Он предоставляет пользовательский элемент, который использует идентификатор видео YouTube и представляет собой минимальную миниатюру и кнопку воспроизведения. Щелчок по элементу динамически загружает полный код для встраивания YouTube, что означает, что пользователи, которые никогда не нажимают "Воспроизвести", не платят за его извлечение и обработку.
#### Аутентификация
Приложениям может потребоваться поддерживать аутентификацию с помощью службы через клиентский JavaScript SDK. Иногда они могут быть большими с большими затратами на выполнение JS, и лучше не загружать их заранее, если пользователь не собирается входить в систему. Вместо этого динамически импортируйте библиотеки аутентификации, когда пользователь нажимает на кнопку “Войти”, сохраняя основной поток более свободным при начальной загрузке.
#### Виджеты чата
Приложение Calibre [улучшило производительность своего онлайн-чата на основе внутренней связи на 30%](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/calibreapp.com/blog/fast-live-chat) за счет использования аналогичного фасадного подхода. Они внедрили “поддельную” кнопку быстрой загрузки живого чата, используя только CSS и HTML, которая при нажатии загружала их пакеты внутренней связи.
#### Прочее
[Ne-digital](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/medium.com/ne-digital/how-to-reduce-next-js-bundle-size-68f7ac70c375) использовала библиотеку React для анимированной прокрутки назад к началу страницы, когда пользователь нажимает на кнопку “прокрутка вверх”. Вместо того, чтобы сразу загружать зависимость react-scroll для этого, они загружают ее при взаимодействии с кнопкой, экономя ~ 7 КБ:

```js
handleScrollToTop() {
    import('react-scroll').then(scroll => {
      scroll.animateScroll.scrollToTop({
      })
    })
}
```

### Как осуществляется импорт при взаимодействии?
#### Ванильный JavaScript
В JavaScript, [dynamic import()](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/v8.dev/features/dynamic-import) включает отложенную загрузку модулей и возвращает обещание и может быть довольно мощным при правильном применении. Ниже приведен пример, в котором динамический импорт используется в прослушивателе событий button для импорта модуля Lodash.sortby и последующего его использования.

```js
const btn = document.querySelector("button");

btn.addEventListener("click", (e) => {
  e.preventDefault();
  import("lodash.sortby")
    .then((module) => module.default)
    .then(sortInput()) // use the imported dependency
    .catch((err) => {
      console.log(err);
    });
});
```
#### React
Прервать загрузку этой работы относительно просто с помощью [разделения кода](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/web.dev/reduce-javascript-payloads-with-code-splitting/). Метод `React.lazy` упрощает кодовое разделение приложения React на компонентном уровне с использованием динамического импорта. Функция `React.lazy` предоставляет встроенный способ разделения компонентов приложения на отдельные фрагменты JavaScript с минимальными затратами времени. Затем вы можете позаботиться о состояниях загрузки, связав его с компонентом приостановки.
#### Vue
В Vue.js аналогичный шаблон импорта при взаимодействии может быть выполнен несколькими различными способами. Одним из способов является динамический импорт `Emojipicker` компонента Vue с использованием динамического импорта, обернутого в функцию, т.е. `() => import("./Emojipicker")`. Обычно для этого требуется Vue.js отложенная загрузка компонента, когда его необходимо отрисовывать.
## Import On Visibility
Поскольку мы не запрашиваем все изображения сразу, мы можем сократить время начальной загрузки. То же самое мы можем сделать с компонентами! Чтобы узнать, находятся ли компоненты в данный момент в нашем окне просмотра, мы можем использовать [`IntersectionObserver` API](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) или использовать библиотеки, такие как `react-lazyload` или `react-loadable-visibility`, чтобы быстро добавить импорт по видимости в наше приложение.
## Optimize your loading sequence
## Prefetch
Предварительная выборка (`<link rel="prefetch">`) - это оптимизация браузера, которая позволяет нам извлекать ресурсы, которые могут потребоваться для последующих маршрутов или страниц, до того, как они понадобятся. Предварительной выборки можно добиться несколькими способами. Это может быть сделано декларативно в HTML (например, в примере ниже), с помощью HTTP-заголовка (`Link: </js/chat-widget.js>; rel=prefetch`), [Service Workers](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/googlechrome.github.io/samples/service-worker/prefetch/) или с помощью более пользовательских средств, таких как Webpack.

### webpackPrefetch
Компоненты или ресурсы, которые, как мы знаем, могут быть использованы в какой-то момент приложения, могут быть **предварительно выбраны**. Мы можем сообщить Webpack, что определенные пакеты нуждаются в предварительной выборке, добавив [волшебный комментарий](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/webpack.js.org/api/module-methods/#magic-comments) к инструкции import: `/* webpackPrefetch: true */`.

Хотя предварительная выборка - отличный способ оптимизировать время загрузки, не переусердствуйте. Если пользователь в итоге так и не запросил `EmojiPicker` компонент, мы напрасно загрузили ресурс. Это потенциально может стоить пользователю денег или замедлить работу приложения. Выполняйте только предварительную выборку необходимых ресурсов.

Приведенные ниже ресурсы по предварительной выборке могут оказаться полезными:

- [Предварительная загрузка, предварительная выборка и приоритеты в Chrome](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf)
- [Более быстрая навигация благодаря упреждающей выборке](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/web.dev/predictive-prefetching/)
- [Эвристика предварительной выборки](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/blog.mgechev.com/2021/02/07/prefetching-strategies-heuristics-faster-web-apps/)
- [Чего не следует выполнять предварительную выборку](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/addyosmani.com/blog/what-not-to-prefetch-prerender/)
## Preload
[Предварительная загрузка](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content) (`<link rel="preload">`) - это [оптимизация браузера](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/web.dev/uses-rel-preload/), которая позволяет запрашивать критически важные ресурсы (которые могут быть обнаружены с опозданием) раньше. Если вам удобно думать о том, как вручную упорядочить загрузку ваших ключевых ресурсов, это может оказать положительное влияние на производительность загрузки и показатели в [основных веб-ресурсах](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/web.dev/vitals). Тем не менее, предварительная загрузка не является панацеей и требует осознания некоторых компромиссов.
### defer
Если вы пытаетесь оптимизировать загрузку JavaScript первого производителя, вы также можете рассмотреть возможность использования `<script defer>` в документе `<head>` против `<body>`, чтобы облегчить раннее обнаружение этих ресурсов.

### webpackPreload
Webpack 4.6.0+ позволяет предварительно загружать ресурсы, добавляя `/* webpackPreload: true */` к импорту. Чтобы предварительная загрузка работала в старых версиях webpack, вам нужно добавить [`preload-webpack-plugin`](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/github.com/GoogleChromeLabs/preload-webpack-plugin) в конфигурацию вашего webpack.

Предварительно загруженный пакет `EmojiPicker` может быть загружен параллельно с исходным пакетом. В отличие от `prefetch`, когда браузер по-прежнему имел право голоса в том, считает ли он, что у него достаточно хорошее интернет-соединение и пропускная способность для фактической предварительной выборки ресурса, **предварительно загруженный** ресурс будет загружен независимо ни от чего.

Множество статей web.dev посвящены тому, как использовать предварительную загрузку для:

- [Предварительная загрузка ключевых скриптов, необходимых для интерактивности](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/web.dev/uses-rel-preload/)
- [Предварительно загрузите свое самое большое и насыщенное изображение Paint](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/web.dev/preload-responsive-images/)
- [Загружайте шрифты, предотвращая смещение макета](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/web.dev/preload-optional-fonts/)
## PRPL Pattern
PRPL — это аббревиатура, описывающая шаблон, используемый для ускорения загрузки веб-страниц и их интерактивности:

- **Предварительная загрузка** поздно обнаруженных ресурсов.
- **Отрисуйте** первоначальный маршрут как можно скорее.
- **Предварительно кэшируйте** оставшиеся ресурсы.
- **Ленивая загрузка** других маршрутов и некритических ресурсов.
## Optimize loading third-parties
partytown
## Tree Shaking
### Концепции
Обработка дерева предназначена для удаления кода, который никогда не будет использоваться, из окончательного пакета JavaScript. При правильном выполнении это может уменьшить размер ваших пакетов JavaScript и сократить время загрузки, синтаксического анализа и (в некоторых случаях) выполнения. Для большинства современных приложений JavaScript, использующих модульный пакет (например, webpack или Rollup), ваш пакет - это то, что, как вы ожидаете, автоматически удалит мертвый код. ⁣⁣ ⁣⁣
### Импорт
Только модули, определенные с помощью синтаксиса модуля ES2015 (`import` и `export`), могут быть преобразованы в дерево. Способ импорта модулей определяет, может ли модуль быть преобразован в дерево или нет.
### Побочные эффекты
Когда мы импортируем модуль ES6, этот модуль выполняется мгновенно. Может случиться так, что, хотя мы нигде в нашем коде не ссылаемся на экспорт модуля, сам модуль влияет на глобальную область во время выполнения (например, полизаполнения или глобальные таблицы стилей). Это называется **побочным эффектом**. Хотя мы не ссылаемся на экспорт самого модуля, _если_ модуль изначально экспортировал значения, модуль не может быть преобразован в дерево из-за особого поведения при импорте!
## List Virtualization
Если вы используете React и вам необходимо **эффективно отображать большие списки данных**, возможно, вы знакомы с [react-virtualized](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/bvaughn.github.io/react-virtualized/). Это оконная библиотека от [Брайана Вона](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/twitter.com/brian_d_vaughn), которая отображает только элементы, видимые в данный момент в списке (в прокручиваемом “окне просмотра”). Это означает, что вам не нужно оплачивать стоимость одновременного отображения тысяч строк данных. К этой статье прилагается [видео](https://translated.turbopages.org/proxy_u/en-ru.en.18603996-65e0e07f-03b6a1d0-74722d776562/https/www.youtube.com/embed/QhPn6hLGljU) с пошаговым руководством по виртуализации списков с помощью react-window.
### libs
#### react-virtualized
#### react-window
#### react-window-infinite-loader
### Improvements in the web platform
Some modern browsers now support [CSS content-visibility](https://web.dev/content-visibility/). `content-visibility:auto` allows you to skip rendering & painting offscreen content until needed. If you have a long HTML document with costly rendering, consider trying the property out.

For rendering lists of dynamic content, I still recommend using a library like react-window. It would be hard to have a `content-visbility:hidden` version of such a library that beats a version aggressively using `display:none` or removing DOM nodes when offscreen like many list virtualization libraries may do today.

## [[Debounce]]

## [[Throttling]]

## Другое

### Использовать фреймворки если приложение более менее большое

### Не тяни весь npm к себе

### isDesktop && isMobile + i18n

### Самописный SSR

### redux dynamic modules

### ReRendering
[[memo]]
[[useMemo()]]
[[useCallback()]]
#### Декомпозиция

### [[Redux]]
#### reselect
