---
tags:
  - solid
links:
  - https://solidbook.vercel.app/srp
---
Принцип единственной ответственности (Single Responsibility Principle, SRP) означает, что ==у модуля должна быть только одна причина для изменения.== 
Весь код, который меняется по этой причине, должен быть собран в этом модуле.

Проще говоря принцип предлагает нам проводить границы между модулями так, чтобы изменение в бизнес-правилах затрагивало как можно меньше модулей, в идеале — один.

Основной инструмент принципа — объединять те части, которые меняются по одной причине, и разделять те, которые меняются по разным.

Принцип позволяет уменьшить количество кода, который нужно менять при изменении бизнес-правил. Он помогает ограничить влияние этих изменений и контролировать сложность программы.

## Коротко

Принцип единственной ответственности:

- помогает разбивать и декомпозировать задачи по одной на модуль;
- уменьшает количество модулей, которые надо изменить при изменении требований;
- ограничивает влияние изменений, помогая контролировать сложность системы.

# В идеальном мире
## Отчёт

Мы создадим класс `ReportExporter`, который будет заниматься только экспортом данных. Определять необходимый формат будет класс `FormatSelector`. А форматированием данных будут заниматься классы: `HtmlFormatter` и `TxtFormatter`.

```js
// Тип данных для отчёта:

type ReportData = {
  content: string,
  date: Date,
  size: number,
}

// Возможные форматы:

enum ReportTypes {
  Html,
  Txt,
}

// Класс, который занимается экспортом данных:

class ReportExporter {
  name: string
  data: ReportData

  constructor(name: string, data: ReportData) {
    this.name = name
    this.data = data
  }

  export(reportType: ReportTypes): string {
    const formatter: Formatter = FormatSelector.selectFor(reportType)
    return formatter.format(this.data)
  }
}
```
## Форматы экспорта

В соответствии с SRP форматирование данных — это _отдельная задача_. Поэтому для преобразования данных отчёта в необходимый формат мы создадим отдельные классы.

```js
interface Formatter {
  format(data: ReportData): string
}

// Класс для форматирования в HTML:
class HtmlFormatter implements Formatter {
  format(data: ReportData): string {

    // ...Форматируем данные в HTML и возвращаем:
    return 'html string'
  }
}

// Класс для форматирования в TXT:
class TxtFormatter implements Formatter {
  format(data: ReportData): string {

    // ...Форматируем данные в TXT и возвращаем:
    return 'txt string'
  }
}
```

## Выбор формата

Принцип единственной ответственности подсказывает, что выбор формата не входит ни в задачу форматирования данных, ни в задачу их подготовки. Поэтому существующие классы нам не подойдут.

Для решения этой задачи воспользуемся шаблоном проектирования [«Стратегия»](https://refactoring.guru/ru/design-patterns/strategy), который поможет выбрать подходящий формат. (Более подробно «Стратегию» мы разберём в [разделе о принципе открытости и закрытости](https://solidbook.vercel.app/ocp/patterns).)

Создадим новый класс `FormatSelector`, который будет выбирать тип форматирования, в зависимости от настроек.

```js
class FormatSelector {
  private static formatters = {
    [ReportTypes.Html]: HtmlFormatter,
    [ReportTypes.Txt]: TxtFormatter,
  }

  static selectFor(reportType: ReportTypes) {
    const FormatterFactory = FormatSelector.formatters[reportType]
    return new FormatterFactory();
  }
}

const dynamicFormatter = FormatSelector.selectFor(ReportTypes.Html)
dynamicFormatter.format(/*...*/)
```

Таким образом SRP помогает разделить ответственность за различные задачи между сущностями и сделать это так, чтобы каждая сущность занималась одной задачей.

# В реальной жизни

В реальной жизни SRP также позволяет решать задачи эффективнее. Ниже мы привели несколько примеров из проектов, над которыми работали.

## Валидация форм

В вебе одна из распространённых задач — валидация форм.

По принципу единственной ответственности следует разделять код, который меняется по разным причинам. В случае с валидацией формы есть две зоны ответственности.

Первая — представление данных: вывод полей, значений, прогресса заполненности формы, ошибок и прочее. 

Вторая — преобразование и обработка данных. Валидация попадает во вторую.

В идеале валидация не должна ничего знать о том, в каком виде данные выводятся. Она должна работать только со значениями и принимать наборы данных в обговорённом формате, не привязываясь к форме вовсе.

### Применение SRP для валидации позволяет:

- уменьшить код обработчиков форм, выделив валидацию в отдельный модуль;
- держать валидацию значений в одном месте, собрав всё, что к ней относится в одном модуле;
- валидировать не только формы, а любые наборы данных, которые соответствуют обговорённому формату валидатора.
## Обработка сокет-событий

Если в системе есть компоненты, которые каким-то образом работают с сокет-событиями, есть соблазн обрабатывать эти события прямо внутри компонента. 

На первый взгляд это даже не противоречит принципу: ведь события непосредственно связаны с компонентом и задачей, которую он решает.

Но события в компоненте — это не обязательно сокет-события. У компонента по-хорошему должен быть интерфейс, который бы описывал события компонента и его поведение. (Подробнее об интерфейсах мы поговорим в разделе о [принципе разделения интерфейса](https://solidbook.vercel.app/isp).)


==По SRP настройку работы именно с сокетами следует вынести в отдельный модуль, причиной изменения которого будет только настройка и зависимость сокетов.==

## Настройка бюджета во второй версии Тяжеловато

*[Тяжеловато](http://www.fuckgrechka.ru/tzlvt/) — это приложение, которое помогает экономить. Пользователи указывают, сколько денег у них есть и на какой срок они хотят их растянуть. Приложение рассчитывает бюджет и сумму на день.*

*В первой версии бюджет и сумма на день были частями одной сущности — бюджета. Это сильно усложняло расчёты и увеличивало объём обработчиков пользовательских событий.*

По принципу единственной ответственности **работа с суммой на день и с общим бюджетом на весь период — разные задачи.**

Причина изменения суммы на день — ввод траты; 
причина изменения бюджета — изменение настроек бюджета.

В обновлённой версии бюджет и сумма на день стали отдельными сущностями, которые общаются друг с другом через сообщения и команды.

Это позволило:

- уменьшить количество эдж-кейсов при расчётах сумм;
- сделать общение между сущностями более прозрачным;
- разделить ответственность за обработку трат и настроек.

# Шаблоны проектирования и приёмы рефакторинга

## [[Выделение класса]]

## [[Фасад]]

## [[Прокси]]

# Антипаттерны и запахи

## [[Божественный объект]]
Проблема таких объектов в том, что внутри них скапливается неоправданно большое количество данных. Со временем может случиться, что никакое действие нельзя будет сделать без участия божественного объекта.

Это затрудняет рефакторинг, тестирование и внесение изолированных изменений в код.
## [[Синглтон]]

С точки зрения SRP это смешение ответственностей. ==Потому что синглтон не только выполняет свою основную функцию, но ещё и проверяет, не существует ли уже созданных экземпляров.==

Проблем у этого паттерна несколько:

- он глобален — когда нарушается инкапсуляция состояния, повышается вероятность непредсказуемых нежелательных изменений;
- излишне имплицитен — трудно заранее понять, как себя поведёт объект в какой-то ситуации;
- трудно тестируется — глобальный объект хранит большое количество данных и может находиться в большом количестве различных состояний, из-за чего модульные тесты могут показывать непредсказуемые результаты.

## Смешение архитектурных слоёв

[Паттерн Model-View-Controller, MVC](https://ru.wikipedia.org/wiki/Model-View-Controller) подразумевает три сущности: 
- модель, 
- представление 
- и контроллер. 

Модель отвечает за хранение данных; 
представление — за их отображение; 
контроллер — за преобразование и обработку.

Смешение слоёв — это неправильное распределение или размазывание ответственностей между слоями. Оно может приводить:

- к [разрастанию контроллера](https://gunnarpeipman.com/aspnet/why-to-avoid-fat-controllers/), что делает его код трудным для понимания;
- появлению логики внутри модели, что затрудняет переиспользование модели.
# Ограничения и подводные камни

У каждого принципа есть ограничения и область применения. Для SRP характерны следующие ограничения и подводные камни.

## Слепое следование опасно

Слепое следование принципу (например, преждевременная оптимизация) ==может создать лишние абстракции и сделать программу чрезмерно сложной.== Использовать SRP стоит тогда, когда вносить изменения в класс, нарушающий его, становится дорого.

## Трудность начального проектирования

Выделить зоны ответственности сущностей при первичном проектировании иногда бывает трудно. Взаимодействие сущностей может быть неочевидным, из-за чего проектировщикам может быть трудно определиться с методами классов. В этом случае могут помочь прототипирование и диаграммное моделирование:

- Unified Modeling Language, UML;
- Data flow diagram, DFD;
- Entity relationship diagram, ERD;
- Методология моделирования IDEF.

## Разработка через тестирование — не панацея, а инструмент

Считается, что разработка через тестирование (Test driven development, TDD) может помочь выделить в классах необходимые методы, но это тоже помогает не всегда. ==TDD определённо показывает, каким будет видеть наше API пользователь, но он не всегда помогает выделить зоны ответственности модулей.==