---
tags:
  - javascript
links:
  - https://learn.javascript.ru/microtask-queue
---
Обработчики промисов `.then`/`.catch`/`.finally` всегда асинхронны.

Даже когда промис сразу же выполнен, код в строках _ниже_ `.then`/`.catch`/`.finally` будет запущен до этих обработчиков.

## Очередь микрозадач

Асинхронные задачи требуют правильного управления.
Для этого стандарт предусматривает внутреннюю очередь `PromiseJobs`, более известную как «очередь микрозадач (microtask queue)» (термин V8).

Как сказано в [спецификации](https://tc39.github.io/ecma262/#sec-jobs-and-job-queues):

- Очередь определяется как первым-пришёл-первым-ушёл (FIFO): задачи, попавшие в очередь первыми, выполняются тоже первыми.
- Выполнение задачи происходит только в том случае, если ничего больше не запущено.

Или, проще говоря, когда `промис` выполнен, его обработчики `.then/catch/finally` попадают в очередь. 
Они пока не выполняются. 
Движок JavaScript берёт задачу из очереди и выполняет её, когда он освободится от выполнения текущего кода.

Обработчики промисов всегда проходят через эту внутреннюю очередь.

Если есть цепочка с несколькими `.then/catch/finally`, то каждый из них выполняется асинхронно. То есть сначала ставится в очередь, а потом выполняется, когда выполнение текущего кода завершено и добавленные ранее в очередь обработчики выполнены.
## Итого

Обработка промисов всегда асинхронная, т.к. все действия промисов проходят через внутреннюю очередь [[#Очередь микрозадач|«promise jobs»]], так называемую «очередь микрозадач (microtask queue)» (термин v8).

Таким образом, обработчики `.then/catch/finally` вызываются после выполнения текущего кода.

Если нам нужно гарантировать выполнение какого-то кода после `.then/catch/finally`, то лучше всего добавить его вызов в цепочку `.then`.